2025～2026年秋季学期



《人工智能技术》课程实验报告

实验二  知识表示方法



       学  生  姓  名：          王耀彬                      
       
       学          号：       2025354100103                          
       
       专  业  班  级：         智能专研25                   




实验二  知识表示方法
1．实验目的
　　（1）了解知识表示相关技术；
　　（2）掌握问题规约法或者状态空间法的分析方法。
2．实验内容（2个实验内容可以选择1个实现）
　　（1）梵塔问题实验。熟悉和掌握问题规约法的原理、实质和规约过程；理解规约图的表示方法；
　　（2）状态空间法实验。从前有一条河，河的左岸有m个传教士、m个野人和一艘最多可乘n人的小船。约定左岸，右岸和船上或者没有传教士，或者野人数量少于传教士，否则野人会把传教士吃掉。搜索一条可使所有的野人和传教士安全渡到右岸的方案。
3．实验报告要求
　　（1）简述实验原理，并请给出实现算法及程序流程图。
　　1.问题重述：
　　・初始状态：河的左岸有m个传教士、m个野人和一艘最多可乘n人的小船
　　・约束条件：在任何时刻，任何地点（左岸、右岸或船上），传教士数量必须 >= 野人数量。但当某地没有传教士时，任意数量的野人都是安全的。否则（不满足约束条件），传教士会被野人吃掉。
　　・目标状态：所有的传教士和野人都安全乘船到右岸
　　2.实验核心思想：
　　・状态定义(m_l,w_l,boot)表示某时刻的状态(左岸传教士，左岸野人，船位置)
　　・状态合法性：m\geq w=\ 0\ and\ m_l+m_r=m\ and\ w_l+w_r=m
　　・状态转移：枚举所有的可能上传组合（BFS）
　　3.实验步骤概括：
　　・利用广度优先搜索，暴力枚举所有可能的上传组合。
　　・算法伪代码：
3.1 初始状态
- Initial = (m, m, 0)
- goal = (0, 0, 1)
- 创建队列 Q，放入 initial
- 创建已访问集合 visited，加入 initial
- 创建父节点字典 parent，用于回溯路径
3.2 BFS枚举
   while Q 非空：
      a. state <- Q.dequeue()
      b. if state == goal：
            return reconstruct_path(state)  // 找到解决方案
      c. for 所有合法的后继状态 next_state：
            if next_state 不在 visited 中：
               visited.add(next_state)
               parent[next_state] <- state
               Q.enqueue(next_state)
3.3 枚举结束，最终结束条件
   return None                            // 无解

3. 路径回溯：
   path <- []
   current <- goal
   while current 非空：
      path.prepend(current)
      current <- parent[current]
   return path　　・核心函数实现及概述：
def is_valid_state(self, ml: int, wl: int, mr: int, wr: int) -> bool:
    # 1. 检查数量范围
    if ml < 0 or wl < 0 or mr < 0 or wr < 0:
        return False
    # 2. 检查总人数守恒
    if ml + mr != self.m or wl + wr != self.m:
        return False
    # 3. 检查各地点是否安全
　　return self.is_safe(ml, wl) and self.is_safe(mr, wr)
　　
def search(self) -> Optional[List[Tuple[int, int, int]]]:
    initial_state = (self.m, self.m, 0)  # 初始状态
    goal_state = (0, 0, 1)                 # 目标状态
    
    # 初始化 BFS
    queue = deque([initial_state])
    self.visited.add(initial_state)
    self.parent[initial_state] = None
    
    # BFS 循环
    while queue:
        current_state = queue.popleft()
        
        if current_state == goal_state:
            return self.reconstruct_path(goal_state)
        
        for next_state in self.get_next_states(current_state):
            if next_state not in self.visited:
                self.visited.add(next_state)
                self.parent[next_state] = current_state
                queue.append(next_state)
    
    return None  # 无解　　4.算法流程图、程序流程图：


　　（2）源程序清单。要求符合一般的程序书写风格，并包括必要的注释。
"""
传教士与野人渡河问题 - 状态空间搜索算法
问题重述：
- 河的左岸有 m 个传教士、m 个野人和一艘最多可乘 n 人的小船
- 约束条件：任何时刻（左岸、右岸或船上），传教士数量必须 >= 野人数量，
??否则野人会把传教士吃掉（特殊情况：无传教士时，任意数量野人都可以）
- 目标：找到一条方案使所有的野人和传教士安全渡到右岸
问题解答：
使用 BFS 求解：通过状态空间搜索找到最短的渡河方案
状态表示：(ml, wl, boat_pos) 其中：
??- ml: 左岸传教士数量
??- wl: 左岸野人数量
??- boat_pos: 船的位置 (0=左岸, 1=右岸)
"""
from collections import deque
from typing import List, Tuple, Optional
class MissionariesAndCannibals:
????"""传教士与野人渡河问题求解器"""
?????
????def __init__(self, m: int, n: int):
????????# m: 传教士和野人的数量（各m个）、n: 小船最大容量
????????self.m = m? # 传教士/野人数量
????????self.n = n? # 船的容量
????????self.visited = set()? # 已访问的状态集合
????????self.parent = {}? # 状态转移记录（用于回溯路径）
?????
????def is_safe(self, missionaries: int, cannibals: int) -> bool:
????????# 无传教士时安全，或传教士 >= 野人时安全
????????return missionaries == 0 or missionaries >= cannibals
?????
????def is_valid_state(self, ml: int, wl: int, mr: int, wr: int) -> bool:
????????"""
????????判断一个状态是否合法（所有位置都满足约束）
????????ml, wl: 左岸的传教士和野人数量
????????mr, wr: 右岸的传教士和野人数量
????????"""
????????# 检查数量范围
????????if ml < 0 or wl < 0 or mr < 0 or wr < 0:
????????????return False
????????if ml + mr != self.m or wl + wr != self.m:
????????????return False
????????return self.is_safe(ml, wl) and self.is_safe(mr, wr)
?????
????def get_next_states(self, state: Tuple[int, int, int]) -> List[Tuple[int, int, int]]:
????????# 从当前状态出发，小船可以到达的所有合法状态
????????ml, wl, boat_pos = state
????????mr = self.m - ml
????????wr = self.m - wl
????????next_states = []
?????????
????????if boat_pos == 0:? # 船在左岸，从左岸到右岸
????????????# 尝试所有可能的上船组合 (i个传教士，j个野人)
????????????for i in range(self.m + 1):
????????????????for j in range(self.m + 1):
????????????????????# 检查上船的人数
????????????????????if 1 <= i + j <= self.n and i <= ml and j <= wl:
????????????????????????# 计算新的状态
????????????????????????new_ml = ml - i
????????????????????????new_wl = wl - j
????????????????????????new_mr = mr + i
????????????????????????new_wr = wr + j
?????????????????????????
????????????????????????# 检查状态合法性
????????????????????????if self.is_valid_state(new_ml, new_wl, new_mr, new_wr):
????????????????????????????next_states.append((new_ml, new_wl, 1))
?????????
????????else:? # 船在右岸，从右岸到左岸
????????????# 尝试所有可能的上船组合 (i个传教士，j个野人)
????????????for i in range(self.m + 1):
????????????????for j in range(self.m + 1):
????????????????????# 检查上船的人数
????????????????????if 1 <= i + j <= self.n and i <= mr and j <= wr:
????????????????????????# 计算新的状态
????????????????????????new_ml = ml + i
????????????????????????new_wl = wl + j
????????????????????????new_mr = mr - i
????????????????????????new_wr = wr - j
????????????????????????if self.is_valid_state(new_ml, new_wl, new_mr, new_wr):
????????????????????????????next_states.append((new_ml, new_wl, 0))
?????????
????????return next_states
?????
????def search(self) -> Optional[List[Tuple[int, int, int]]]:
????????# BFS
????????# 初始状态：所有传教士和野人都在左岸，船也在左岸
????????initial_state = (self.m, self.m, 0)
????????# 目标状态：所有传教士和野人都在右岸，船也在右岸
????????goal_state = (0, 0, 1)
?????????
????????# 初始化
????????queue = deque([initial_state])
????????self.visited.add(initial_state)
????????self.parent[initial_state] = None
?????????
????????# BFS
????????while queue:
????????????current_state = queue.popleft()
????????????if current_state == goal_state:
????????????????return self.reconstruct_path(goal_state)
?????????????
????????????for next_state in self.get_next_states(current_state):
????????????????if next_state not in self.visited:
????????????????????self.visited.add(next_state)
????????????????????self.parent[next_state] = current_state
????????????????????queue.append(next_state)
?????????
????????return None? # 无解
?????
????def reconstruct_path(self, goal_state: Tuple[int, int, int]) -> List[Tuple[int, int, int]]:
????????"""
????????从目标状态回溯得到完整的路径
????????"""
????????path = []
????????current = goal_state
?????????
????????while current is not None:
????????????path.append(current)
????????????current = self.parent[current]
?????????
????????path.reverse()
????????return path
?????
????def format_state(self, state: Tuple[int, int, int]) -> str:
????????"""
????????状态转换
????????"""
????????ml, wl, boat_pos = state
????????mr = self.m - ml
????????wr = self.m - wl
?????????
????????boat_location = "左岸" if boat_pos == 0 else "右岸"
?????????
????????return f"左岸: {ml}传 {wl}野 | 右岸: {mr}传 {wr}野 | 船在: {boat_location}"
?????
????def print_solution(self, path: List[Tuple[int, int, int]]) -> None:
????????print("\n" + "="*60)
????????print(f"传教士与野人渡河问题求解结果 (m={self.m}, 船容量={self.n})")
????????print("="*60)
?????????
????????print(f"\n初始状态：")
????????print(f"? {self.format_state(path[0])}")
?????????
????????print(f"\n渡河步骤：")
????????for step in range(1, len(path)):
????????????prev_state = path[step - 1]
????????????curr_state = path[step]
?????????????
????????????# 计算这一步上船的人数
????????????missionaries_moved = abs(curr_state[0] - prev_state[0])
????????????cannibals_moved = abs(curr_state[1] - prev_state[1])
?????????????
????????????direction = "左→右" if prev_state[2] == 0 else "右→左"
?????????????
????????????print(f"\n? 步骤 {step}：")
????????????print(f"??? 方向：{direction}")
????????????print(f"??? 上船：{missionaries_moved}个传教士, {cannibals_moved}个野人")
????????????print(f"??? {self.format_state(curr_state)}")
?????????
????????print(f"\n目标达成！共用 {len(path) - 1} 步骤完成渡河")
????????print("="*60 + "\n")
def main():
????print("="*60)
?????
????# 设置问题参数
????m = 100? # 传教士和野人各m个
????n = 64? # 小船最多乘n人
?????
????print(f"问题参数：")
????print(f"? 初始左侧传教士数量: {m}个")
????print(f"? 初始左侧野人数量: {m}个")
????print(f"? 初始小船容量: {n}人")
????print(f"? 初始状态: 所有人都在左岸")
????print(f"? 目标状态: 所有人都到右岸")
?????
????# 创建求解器并搜索
????solver = MissionariesAndCannibals(m, n)
????solution = solver.search()
?????
????if solution:
????????solver.print_solution(solution)
????else:
????????print(f"\n不存在可能的解决方案")
????????print(f"(m={m}, 船容量={n})")
????????print("="*60 + "\n")
if __name__ == "__main__":
????main()

　　（3）实验结果及分析。
	1.以\left(3,\ 3,0\right)\ and\ n=2为例，程序输出如下：
============================================================
问题参数：
  初始左侧传教士数量: 3个
  初始左侧野人数量: 3个
  初始小船容量: 2人
  初始状态: 所有人都在左岸
  目标状态: 所有人都到右岸

============================================================
传教士与野人渡河问题求解结果 (m=3, 船容量=2)
============================================================

初始状态：
  左岸: 3传 3野 | 右岸: 0传 0野 | 船在: 左岸

渡河步骤：

  步骤 1：
    方向：左→右
    上船：0个传教士, 2个野人
    左岸: 3传 1野 | 右岸: 0传 2野 | 船在: 右岸

  步骤 2：
    方向：右→左
    上船：0个传教士, 1个野人
    左岸: 3传 2野 | 右岸: 0传 1野 | 船在: 左岸

  步骤 3：
    方向：左→右
    上船：0个传教士, 2个野人
    左岸: 3传 0野 | 右岸: 0传 3野 | 船在: 右岸

  步骤 4：
    方向：右→左
    上船：0个传教士, 1个野人
    左岸: 3传 1野 | 右岸: 0传 2野 | 船在: 左岸

  步骤 5：
    方向：左→右
    上船：2个传教士, 0个野人
    左岸: 1传 1野 | 右岸: 2传 2野 | 船在: 右岸

  步骤 6：
    方向：右→左
    上船：1个传教士, 1个野人
    左岸: 2传 2野 | 右岸: 1传 1野 | 船在: 左岸

  步骤 7：
    方向：左→右
    上船：2个传教士, 0个野人
    左岸: 0传 2野 | 右岸: 3传 1野 | 船在: 右岸

  步骤 8：
    方向：右→左
    上船：0个传教士, 1个野人
    左岸: 0传 3野 | 右岸: 3传 0野 | 船在: 左岸

  步骤 9：
    方向：左→右
    上船：0个传教士, 2个野人
    左岸: 0传 1野 | 右岸: 3传 2野 | 船在: 右岸

  步骤 10：
    方向：右→左
    上船：0个传教士, 1个野人
    左岸: 0传 2野 | 右岸: 3传 1野 | 船在: 左岸

  步骤 11：
    方向：左→右
    上船：0个传教士, 2个野人
    左岸: 0传 0野 | 右岸: 3传 3野 | 船在: 右岸

目标达成！共用 11 步骤完成渡河
============================================================　・输出分析：每一步都满足安全约束、共用11步完成渡河、搜索了32个状态。
　・为什么需要野人先渡河：在第1步，让2个野人先渡河，而不是传教士和野人混合：如果1个传教士+ 1个野人渡河，左岸剩余2传2野，则不安全（野=传）只有2个野人渡河，左岸剩余3传1野，则安全。
　2.时间复杂度分析：
　・状态总数上界：\left(m+1\right)^2\times2
　・时间复杂度O\left(\left(m+1\right)^2\times m^2\right)=O\left(m^4\right)
　3.另例：
初始状态：n=100
  左岸: 100传 100野 | 右岸: 0传 0野 | 船在: 左岸

渡河步骤：

  步骤 1：
    方向：左→右
    上船：100个传教士, 100个野人
    左岸: 0传 0野 | 右岸: 100传 100野 | 船在: 右岸

目标达成！共用 1 步骤完成渡河

初始状态：n=98
  左岸: 100传 100野 | 右岸: 0传 0野 | 船在: 左岸

渡河步骤：

  步骤 1：
    方向：左→右
    上船：0个传教士, 7个野人
    左岸: 100传 93野 | 右岸: 0传 7野 | 船在: 右岸

  步骤 2：
    方向：右→左
    上船：0个传教士, 1个野人
    左岸: 100传 94野 | 右岸: 0传 6野 | 船在: 左岸

  步骤 3：
    方向：左→右
    上船：52个传教士, 46个野人
    左岸: 48传 48野 | 右岸: 52传 52野 | 船在: 右岸

  步骤 4：
    方向：右→左
    上船：1个传教士, 1个野人
    左岸: 49传 49野 | 右岸: 51传 51野 | 船在: 左岸

  步骤 5：
    方向：左→右
    上船：49个传教士, 49个野人
    左岸: 0传 0野 | 右岸: 100传 100野 | 船在: 右岸

目标达成！共用 5 步骤完成渡河
4．本次实验总结体会
　　学习到了：
　　・状态空间搜索：将复杂的决策问题转化为图搜索问题，通过BFS保证找到最优解。
　　・约束满足问题（CSP）的处理：在状态生成时就进行剪枝，提高搜索效率。
　　・了解了知识表示相关技术
　　・掌握了问题规约法或者状态空间法的分析方法。

5．对本实验方法的改进建议
・可以计划使用高级算法。例如A*、动态规划。
・采用双向搜索：从初始状态和目标状态同时搜索，减少搜索树的规模。



