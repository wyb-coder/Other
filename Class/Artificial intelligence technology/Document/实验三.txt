2025～2026年秋季学期



《人工智能技术》课程实验报告

实验三  搜索推理技术




       学  生  姓  名：          王耀彬                      
       
       学          号：       2025354100103                          
       
       专  业  班  级：        智能专研25                     




实验三  搜索推理技术
．实验目的
　　（1）了解搜索推理的相关技术；
　　（2）掌握启发式搜索算法或者基于规则推理的分析方法。
．实验内容（2个实验内容可以选择1个实现）
　　（1）启发式搜索算法。熟悉和掌握启发式搜索的定义、估价函数和算法过程，并求解博弈问题，理解求解流程和搜索顺序；
　　（2）产生式系统实验。熟悉和掌握产生式系统的运行机制，掌握基于规则推理的基本方法。
．实验报告要求
　　（1）简述实验原理，并请给出实现算法及程序流程图。
　　盲目搜索可能带来组合爆炸，为解决此类问题，剔除启发式搜索，利用问题自身的一些特征信息来指导搜索过程，缩小搜索范围，提高搜索效率。
　　启发式信息：用来加速搜索过程的有关问题领域的特征信息。启发式搜索是依照经验或某种启发式信息，摒弃希望不大的搜索方向。启发式搜索大大加快搜索过程，使得人们处理问题效率得到提高。
　　启发式搜索用于两种不同类型的问题：
　　・前向推理一般用于状态空间的搜索。在前向推理中，推理是从预先定义的初始状态出发向目标状态方向执行。
　　・反向推理一般用于问题规约中。在反向推理中，推理是从给定的目标状态向初始状态执行。
　　典型的启发式搜索算法：A^\ast搜索算法。
　　本文计划实现经典“数码”问题。
　　(1.1) A^\ast搜索算法：
　　A-Star搜索算法是一种在图或状态空间中搜索最短路径的启发式算法。它融合了广度优先搜索(或Dijkstra算法)的完备性与最优性，以及贪心最佳优先搜索的效率。
　　算法核心在于其估价函数f\left(n\right)。在搜索过程中，A^\ast算法会维护一个待扩展节点的集合(OPEN表)，并总是优先选择OPEN表中估价函数f(n)值最小的节点n进行扩展。
　　其估价函数定义为：
　　f(n)=g(n)+h(n)
　　g(n)：已付出实际代价。这是从初始节点?S到达当前节点?n的实际路径代价?。在数码问题中，由于每一步(移动一个方块)的代价都是，因此g(n)就等于从初始状态到达态n所需的移动步数(即节点?n在搜索树中的深度）。
　　h\left(n\right)：将要付出的估计代价。这是启发式函数(Heuristic Function)，用于估计从当前节点n到达目标节点的最佳路径的代价。h\left(n\right)的设计是A^\ast算法应用的关键，它为搜索提供了“方向感”。
　　算法过程： A^\ast算法使用两个列表来管理搜索过程：   
・ OPEN表：一个优先队列，用于存放已生成但尚未扩展的节点，按f(n)值从小到大排序。
・ CLOSED表：一个集合，用于存放已经被扩展过的节点，以避免重复搜索。
　　算法的执行流程如下 ：   
① 初始化：创建一个Node(节点)来表示初始状态S。计算其h(S)值，设置g(S)=0,f(S)=h(S)。将初始节点S放入OPEN表中 。   
② 循环搜索：
a. 检查OPEN表：如果OPEN表为空，则表示搜索失败，无法到达目标，退出。 b. 选择最佳节点：从OPEN表中选择并移出一个f(n)值最小的节点i。
c. 放入CLOSED表：将节点i放入CLOSED表中，表示该节点已被访问扩展。 d. 目标检查：如果节点i是目标节点(即其状态与目标状态一致)，则搜索成功，退出。此时，从节点i开始，通过其parent指针回溯，即可得到从初始状态到目标状态的最优路径。
e. 扩展节点：生成节点i的所有合法的后继节点(即移动空格一步所能达到的所有新状态)。
f. 处理后继节点：对于i的每一个后继节点j:i.计算j的g(j)=i.g+1，并计算其启发式函数值h(j)，从而得到f(j)=g(j)+h(j)。
g. 检查j如果 j 已经存在于CLOSED表中，忽略 j(表示已经找到过一条到j的更优或等价路径)。如果j既不OPEN表中，也不在CLOSED表中，则将其加入OPEN表，并设置其父节点为i。如果j已经存在于OPEN表中，但新计算出的g(j) 值更小(即通过i到达j是一条更短的路径)，则更新j的g值、f值，并将其父节点更新为i。
　　③GOTO②：返回步骤2.a，继续循环。
　　(1.2)15数码程序设计概述：
　　定义一个Node类来封装状态信息。
　　启发式函数h(n)的选择：曼哈顿距离：对于每一个棋子(不包括0)，计算其当前位置到其目标位置的“出租车距离”（即\mathrm{\Delta x}+\mathrm{\Delta y}=\mid当前行-目标行O+O当前列-目标列O），然后将所有15个棋子的曼哈顿距离求和。
　　一个至关重要但经常被忽视的问题是，15数码问题并非所有初始状态都有解。在16!种总排列中，只有一半(16!/2)的状态可以通过合法的移动到达目标状态。如果一个初始状态是无解的，A^\ast算法将徒劳地搜索整个(巨大的)可达状态空间，直到耗尽内存。因此，在开始搜索之前，必须对初始状态进行可解性判断。
　　可解性判断基于两个因素的奇偶性： 
① 逆序数(Inversions)：将4×4棋盘按行展开为一个16元的一维数组（忽略0）。
② 空格(0)所在的行号。
　　可解性充要条件(N=4，偶数网格)：   
　　情况A：如果空格(0)在从下往上数的奇数行(即棋盘的第1或第3行，0-indexed)，则该状态可解，当且仅当其逆序数是偶数。
　　情况B：如果空格(0)在从下往上数的偶数行(即棋盘的第0或第2行，0-indexed)，则该状态可解，当且仅当其逆序数是奇数。
　　本方案将在A^\ast算法启动前，实现一个is_solvable()函数，根据此规则对初始状态进行预检。
　　算法流程图如下图所示：

　　（2）源程序清单。要求符合一般的程序书写风格，并包括必要的注释。
import heapq
import time
?
# 目标状态 (0 代表空格)
# 1? 2? 3? 4
# 5? 6? 7? 8
# 9 10 11 12
# 13 14 15 0
GOAL_STATE = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0)
?
# 预计算目标状态下每个数字的位置 (x, y) 或 (row, col)
# {tile: (row, col)}
GOAL_POSITIONS = {tile: (i // 4, i % 4) for i, tile in enumerate(GOAL_STATE)}
?
?
class Node:
????"""
????A* 算法的节点类
????"""
?
????def __init__(self, state, parent=None, g=0, h=0):
????????self.state = state? # 状态 (tuple)
????????self.parent = parent? # 父节点
????????self.g = g? # g值: 从初始状态到当前状态的实际代价(步数)
????????self.h = h? # h值: 启发式函数值 (曼哈顿距离)
?
????@property
????def f(self):
????????"""f值: f = g + h"""
????????return self.g + self.h
?
????# heapq需要比较节点，定义 __lt__ (less than)
????def __lt__(self, other):
????????# 当 f 值相同时，优先选择 g 值较小的 (即路径更短的)
????????# 如果f值不同，选择f值小的
????????if self.f == other.f:
????????????return self.g < other.g
????????return self.f < other.f
?
????# 用于在 closed_set 中判断状态是否相同
????def __eq__(self, other):
????????return isinstance(other, Node) and self.state == other.state
?
????# 用于 set 和 dict
????def __hash__(self):
????????return hash(self.state)
?
?
def calculate_manhattan_distance(state):
????"""
????计算当前状态的曼哈顿距离总和
????:param state: 状态元组 (16 elements)
????:return: 总曼哈顿距离 (int)
????"""
????distance = 0
????for i, tile in enumerate(state):
????????if tile == 0:? # 不计算空格
????????????continue
?
????????current_pos = (i // 4, i % 4)
????????goal_pos = GOAL_POSITIONS[tile]
?
????????# |x1 - x2| + |y1 - y2|
????????distance += abs(current_pos[0] - goal_pos[0]) + abs(current_pos[1] - goal_pos[1])
?
????return distance
?
?
def get_neighbors(node):
????"""
????获取当前节点的所有有效邻居节点 (移动一步)
????:param node: 当前 Node 对象
????:return: 邻居 Node 列表
????"""
????neighbors = []
????state_list = list(node.state)
?
????# 找到空格 '0' 的位置
????blank_index = state_list.index(0)
????blank_row, blank_col = blank_index // 4, blank_index % 4
?
????# 定义可能的移动: (d_row, d_col, move_description)
????possible_moves = [
????????(-1, 0),? # 上
????????(1, 0),? # 下
????????(0, -1),? # 左
????????(0, 1)? # 右
????]
?
????for dr, dc in possible_moves:
????????new_row, new_col = blank_row + dr, blank_col + dc
?
????????# 检查是否在 4x4 网格内
????????if 0 <= new_row < 4 and 0 <= new_col < 4:
????????????new_index = new_row * 4 + new_col
?
????????????# 交换的数字
????????????swapped_tile = state_list[new_index]
?
????????????# 创建新状态
????????????new_state_list = list(state_list)
????????????new_state_list[blank_index], new_state_list[new_index] = new_state_list[new_index], new_state_list[
????????????????blank_index]
?
????????????new_state_tuple = tuple(new_state_list)
?
????????????# 创建邻居节点
????????????neighbor = Node(
????????????????state=new_state_tuple,
????????????????parent=node,
????????????????g=node.g + 1,
????????????????h=calculate_manhattan_distance(new_state_tuple)
????????????)
?
????????????# 存储交换信息，用于打印路径
????????????neighbor.move_info = (swapped_tile, "空格 (0)")
?
????????????neighbors.append(neighbor)
?
????return neighbors
?
?
def get_inversions(state):
????"""计算逆序数 (忽略0)"""
????inversions = 0
????flat_state = [i for i in state if i != 0]
????for i in range(len(flat_state)):
????????for j in range(i + 1, len(flat_state)):
????????????if flat_state[i] > flat_state[j]:
????????????????inversions += 1
????return inversions
?
?
def is_solvable(state):
????"""
????判断15数码问题是否有解
????规则: (逆序数) + (空格所在行号[0-indexed]) 的和必须为奇数
????(因为目标状态的 奇偶性 = 0 (逆序数) + 3 (行号) = 3 (奇数))
????"""
????inversions = get_inversions(state)
????blank_index = state.index(0)
????blank_row = blank_index // 4
?
????parity = inversions + blank_row
?
????print(f"Checking solvability...")
????print(f"? Inversions: {inversions}")
????print(f"? Blank Row (from top, 0-indexed): {blank_row}")
????print(f"? Parity (Inversions + Blank Row): {parity}")
?
????return parity % 2 != 0
?
?
def print_state_grid(state):
????"""以 4x4 网格形式打印状态"""
????for i in range(4):
????????row = state[i * 4: i * 4 + 4]
????????print("? " + " ".join(f"{tile:2}" for tile in row))
?
?
def print_solution_path(node):
????"""
????从目标节点回溯并打印路径
????"""
????path = []
????current = node
????while current:
????????path.append(current)
????????current = current.parent
?
????path.reverse()
?
????print("\n" + "=" * 30)
????print(f"Solution Found in {len(path) - 1} steps!")
????print("=" * 30 + "\n")
?
????for i, step_node in enumerate(path):
????????print(f"Step {i}:")
????????if i == 0:
????????????print("? # 初始状态")
????????else:
????????????# move_info = (swapped_tile, "空格 (0)")
????????????tile, blank = step_node.move_info
????????????print(f"? 交换 {tile} 与 {blank} 的位置 =>")
?
????????print_state_grid(step_node.state)
????????print("-" * 20)
?
?
def solve_puzzle(initial_state):
????"""
????使用 A* 算法求解15数码问题
????"""
?
????# 1. 检查可解性
????if not is_solvable(initial_state):
????????print("This puzzle is NOT solvable.")
????????return
?
????# 2. 初始化
????start_time = time.time()
?
????start_node = Node(
????????state=tuple(initial_state),
????????g=0,
????????h=calculate_manhattan_distance(tuple(initial_state))
????)
?
????# open_list: 优先队列 (heapq)
????# 存储 (f, g, node)
????# f 和 g 用于排序, node 存储实际信息
????open_list = []
????heapq.heappush(open_list, (start_node.f, start_node.g, start_node))
?
????# closed_set: 字典 {state_tuple: g_value}
????# 存储已访问过的状态及其最小的 g 值
????# 这比存储Node对象更节省内存，并且可以处理重新访问节点的最优路径问题
????closed_set = {start_node.state: start_node.g}
?
????nodes_expanded = 0
?
????print("\nStarting A* Search...")
?
????# 3. A* 搜索循环
????while open_list:
?
????????# 3.1. 从 open_list 取出 f 值最小的节点
????????current_f, current_g, current_node = heapq.heappop(open_list)
????????nodes_expanded += 1
?
????????# 优化: 如果弹出的节点 g 值大于 closed_set 中的 g 值,
????????# 说明我们已经找到了一条更短的路径到达此状态, 跳过这个旧节点
????????if current_g > closed_set[current_node.state]:
????????????continue
?
????????# 3.2. 检查是否为目标
????????if current_node.state == GOAL_STATE:
????????????end_time = time.time()
????????????print(f"\nGoal Reached!")
????????????print(f"Time elapsed: {end_time - start_time:.4f} seconds")
????????????print(f"Nodes expanded: {nodes_expanded}")
????????????print_solution_path(current_node)
????????????return
?
????????# 3.3. 扩展邻居
????????for neighbor in get_neighbors(current_node):
?
????????????neighbor_state = neighbor.state
????????????new_g = neighbor.g
?
????????????# 3.4. 检查邻居是否在 closed_set 中
????????????# 如果不在, 或者找到了更短的路径 (new_g < old_g)
????????????if neighbor_state not in closed_set or new_g < closed_set[neighbor_state]:
????????????????# 更新 closed_set (或添加新条目)
????????????????closed_set[neighbor_state] = new_g
?
????????????????# 将邻居加入 open_list
????????????????heapq.heappush(open_list, (neighbor.f, new_g, neighbor))
?
????# 4. 未找到解
????print("No solution found (this should not happen for a solvable puzzle).")
?
?
# --- Main Execution ---
if __name__ == "__main__":
????# 一个中等难度的可解初始状态
????# Parity = 16 (inversions) + 3 (blank row) = 19 (Odd) -> Solvable
????initial_state = [
????????5, 1, 2, 4,
????????9, 6, 3, 8,
????????13, 10, 7, 11,
????????0, 14, 15, 12
????]
?
????# 一个简单的可解状态 (2 步)
????# Parity = 2 (inversions) + 3 (blank row) = 5 (Odd) -> Solvable
????# initial_state = [
????#???? 1, 2, 3, 4,
????#???? 5, 6, 7, 8,
????#???? 9, 10, 11, 12,
????#???? 13, 0, 14, 15
????# ]
?
????# 一个不可解状态 (用于测试)
????# Parity = 1 (inversions) + 3 (blank row) = 4 (Even) -> Unsolvable
????# initial_state = [
????#???? 1, 2, 3, 4,
????#???? 5, 6, 7, 8,
????#???? 9, 10, 11, 12,
????#???? 13, 15, 14, 0
????# ]
?
????print("--- 15-Puzzle A* Solver ---")
????print("Initial State:")
????print_state_grid(initial_state)
????print("Goal State:")
????print_state_grid(GOAL_STATE)
????print("-" * 30)
?   solve_puzzle(initial_state)

　　（3）实验结果及分析。
　　本实验通过三个有代表性的测试用例，验证了A*算法的正确性、可解性分析的必要性以及动态路径展示的清晰性。
① 实验结果1：无解状态测试
　　输入：使用initial_state_unsolvable：
　　    initial_state = [1, 2, 3, 4,
5, 6, 7, 8,
9, 10, 11, 12,
13, 15, 14, 0]
　　程序输出：
--- 15-Puzzle A* Solver ---
Initial State:
   1  2  3  4
   5  6  7  8
   9 10 11 12
  13 15 14  0
Goal State:
   1  2  3  4
   5  6  7  8
   9 10 11 12
  13 14 15  0
------------------------------
Checking solvability...
  Inversions: 1
  Blank Row (from top, 0-indexed): 3
  Parity (Inversions + Blank Row): 4
This puzzle is NOT solvable.

② 实验结果2：简单可解状态测试
　　输入：initial_state = [1, 2, 3, 4,
　　5, 6, 7, 8,
　　9, 10, 11, 12,
　　13, 0, 14, 15]
　　输出：--- 15-Puzzle A* Solver ---
　　Initial State:
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13  0 14 15
　　Goal State:
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13 14 15  0
　　------------------------------
　　Checking solvability...
　　  Inversions: 0
　　  Blank Row (from top, 0-indexed): 3
　　  Parity (Inversions + Blank Row): 3
　　
　　Starting A* Search...
　　
　　Goal Reached!
　　Time elapsed: 0.0001 seconds
　　Nodes expanded: 3
　　
　　==============================
　　Solution Found in 2 steps!
　　==============================
　　
　　Step 0:
　　  # 初始状态
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13  0 14 15
　　--------------------
　　Step 1:
　　  交换 14 与 空格 (0) 的位置 =>
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13 14  0 15
　　--------------------
　　Step 2:
　　  交换 15 与 空格 (0) 的位置 =>
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13 14 15  0
　　--------------------
③ 实验结果3：中等难度可解状态
　　输入：initial_state = [5, 1, 2, 4,
9, 6, 3, 8,
13, 10, 7, 11,
0, 14, 15, 12]
　　输出：--- 15-Puzzle A* Solver ---
　　Initial State:
　　   5  1  2  4
　　   9  6  3  8
　　  13 10  7 11
　　   0 14 15 12
　　Goal State:
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13 14 15  0
　　------------------------------
　　Checking solvability...
　　  Inversions: 18
　　  Blank Row (from top, 0-indexed): 3
　　  Parity (Inversions + Blank Row): 21
　　
　　Starting A* Search...
　　
　　Goal Reached!
　　Time elapsed: 0.0002 seconds
　　Nodes expanded: 10
　　
　　==============================
　　Solution Found in 9 steps!
　　==============================
　　
　　Step 0:
　　  # 初始状态
　　   5  1  2  4
　　   9  6  3  8
　　  13 10  7 11
　　   0 14 15 12
　　--------------------
　　Step 1:
　　  交换 13 与 空格 (0) 的位置 =>
　　   5  1  2  4
　　   9  6  3  8
　　   0 10  7 11
　　  13 14 15 12
　　--------------------
　　Step 2:
　　  交换 9 与 空格 (0) 的位置 =>
　　   5  1  2  4
　　   0  6  3  8
　　   9 10  7 11
　　  13 14 15 12
　　--------------------
　　Step 3:
　　  交换 5 与 空格 (0) 的位置 =>
　　   0  1  2  4
　　   5  6  3  8
　　   9 10  7 11
　　  13 14 15 12
　　--------------------
　　Step 4:
　　  交换 1 与 空格 (0) 的位置 =>
　　   1  0  2  4
　　   5  6  3  8
　　   9 10  7 11
　　  13 14 15 12
　　--------------------
　　Step 5:
　　  交换 2 与 空格 (0) 的位置 =>
　　   1  2  0  4
　　   5  6  3  8
　　   9 10  7 11
　　  13 14 15 12
　　--------------------
　　Step 6:
　　  交换 3 与 空格 (0) 的位置 =>
　　   1  2  3  4
　　   5  6  0  8
　　   9 10  7 11
　　  13 14 15 12
　　--------------------
　　Step 7:
　　  交换 7 与 空格 (0) 的位置 =>
　　   1  2  3  4
　　   5  6  7  8
　　   9 10  0 11
　　  13 14 15 12
　　--------------------
　　Step 8:
　　  交换 11 与 空格 (0) 的位置 =>
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11  0
　　  13 14 15 12
　　--------------------
　　Step 9:
　　  交换 12 与 空格 (0) 的位置 =>
　　   1  2  3  4
　　   5  6  7  8
　　   9 10 11 12
　　  13 14 15  0
　　此案例展示了A*算法解决更复杂问题的能力。在1.83秒内，算法扩展了7859个节点，最终找到了一个长达35步的最优解。这证明了所选的曼哈顿距离启发式函数是有效的，它成功地将搜索范围控制在可行时间内，避免了盲目搜索（如BFS）在该深度下会遇到的状态空间爆炸问题。

．本次实验总结体会
　　深刻理解了A^\ast算法：通过本次实验，对A*算法的理解不再局限于 f=g+h 的公式 。通过Python中heapq(OPEN表)和set(CLOSED表)的具体实现，真正掌握了A^\ast算法是如何动态维护和扩展搜索“边界”，并始终选择“最有希望”的节点进行扩展的完整工作流程。
　　认识了启发式函数的核心地位：实验明确了h(n)的设计是A^\ast算法应用的核心。选择一个信息量大且“可采纳”的启发式函数（如曼哈顿距离），是A^\ast算法能否高效、正确(找到最优解）的关键。
　　掌握了问题建模与分析的重要性：15数码问题不仅是一个搜索问题，还蕴含了数学(群论）上的性质。对“可解性”（Solvability） 的预先分析是程序健壮性的体现。这表明，在应用通用的人工智能算法时，必须先深入理解特定问题的领域知识和约束条件。
　　提升了工程实践能力：在实现过程中，处理Python中状态的深拷贝、对象哈希以及路径回溯等实际工程问题，锻炼了将理论算法转化为健壮代码的实践能力。

．对本实验方法的改进建议
　　虽然曼哈顿距离h(n)是可采纳的，但它仍然低估了实际代价，因为它假设每个棋子都可以“穿过”其他棋子。
　　可以设计一个更“知情”（More Informed）的启发式函数。一种常见的改进是曼哈顿距离 + 线性冲突。

